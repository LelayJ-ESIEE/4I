#define _POSIX_C_SOURCE 200809L

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <sys/mman.h>
#include <sys/stat.h>   /* For mode constants */
#include <fcntl.h>      /* For O_* constants */
#include <unistd.h>     /* for ftruncate */
#include <sys/types.h>
#include <semaphore.h>

#include <getopt.h>

#define MAX_FILE 10
#define MAX_RAND 1023

void reset(){
	printf("reset\n");

	shm_unlink("memory");
	sem_unlink("nonVide");
	sem_unlink("nonPlein");
}

int* init_sem_mem(sem_t ** nonVide, sem_t **nonPlein){

	int fd;
	int* addr;

	if( (fd = shm_open("memory", O_CREAT|O_RDWR, 0777)) == -1) { perror("shm_open"); exit(1); }
	if( ftruncate(fd, MAX_FILE * sizeof(int)) == -1) { perror("ftruncate"); exit(1); }
	if( *(addr = mmap(0, MAX_FILE * sizeof(int), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == -1) { perror("mmap"); exit(1); }

	*nonVide = sem_open("nonVide", O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO, 0);
	*nonPlein = sem_open("nonPlein", O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO, MAX_FILE);

	return addr;
}

void producteur(){

	int * tab;
	sem_t * nonVide;
	sem_t * nonPlein;
	int pos = 0;

	tab = init_sem_mem(&nonVide, &nonPlein);
	/* TODO
	 * int * tab;
	 * sem_t * nonVide;
	 * sem_t * nonPlein;
	 * init_sem_mem(); => initialise tab, nonVide et nonPlein
	 * boucle consommation
	 * munmap()
	 */

	while (1)
	{
		sem_wait(nonPlein);
		tab[pos] = (int) ((rand()/(double) RAND_MAX)*MAX_RAND)+1;
		printf("vbf : at %d, %d\n", pos, tab[pos]);
		sem_post(nonVide);
		pos = (pos+1) % MAX_FILE;
	}
	
	munmap(tab, MAX_FILE * sizeof(int));

}

void consommateur(){

	int * tab;
	sem_t * nonVide;
	sem_t * nonPlein;
	int pos = 0;

	tab = init_sem_mem(&nonVide, &nonPlein);

	while (1)
	{
		sem_wait(nonVide);
		printf("consume at %d : %d\n", pos, tab[pos]);
		sem_post(nonPlein);
		pos = (pos+1) % MAX_FILE; 
	}
	
	munmap(tab, MAX_FILE * sizeof(int));
}

void usage()
{
	printf("must be run with either one of these option : -reset or -r, -producer or -d, -consumer or -c\n");
}

int main(int argc , char * argv[]){

	static struct option long_options[] =
	{
		{"reset",     no_argument, 0, 'r'},
		{"producer",  no_argument, 0, 'p'},
		{"consumer",  no_argument, 0, 'c'},
		{0, 0, 0, 0}
	};
	/* getopt_long stores the option index here. */
	int option_index = 0;
	int c = getopt_long (argc, argv, "rpc",
			long_options, &option_index);

	/* Detect the end of the options. */
	if (c == -1)
		usage();
	else
		switch (c)
		{

			case 'r':
				reset();
				break;

			case 'p':
				srand(time(NULL));
				producteur();
				break;

			case 'c':
				consommateur();
				break;

			default: break;
		}
	if (optind < argc)
	{
		usage();
		while (optind < argc)
			printf ("%s ", argv[optind++]);
		putchar ('\n');
	}


	return 0;
}
