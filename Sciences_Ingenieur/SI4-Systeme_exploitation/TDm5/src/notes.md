# Exercice 1 - on se prépare...

Fichier *mappé* en mémoire : fichier partagé en mémoire, créant un lien entre la mémoire des processus et ce fichier. Cela permet entre autre de communiquer entre processus ou de se substituer aux appels read/write, pouvant se révéler plus rapide dans certains cas que lesdits appels systèmes.

Sémaphores : variable de contrôle, compteur d'autorisations d'accès à une section critique.

Producteur / Consommateur : processus qui génère (respectivement consomme) envoyée au (respectivement reçu de) son processus co-dépendant.

But :
* un programme qui produit de la donnée.
* un consommateur qui vide l'espace, tant qu'il y a en a. Il libère le producteur, si celui-ci avait atteint la taille maximum de l'espace partagé. Les deux programmes tournent en même temps, et s'alimentent/se libèrent l'un l'autre.
* Ils ne se connaissent pas vraiment (pas de tubes possible... ou alors tube nommé) et on veut contrôler la taille de l'échange.

On créé donc un espace mémoire, et on le partage. On a un sémaphore qui nous permet de contrôler qu'on s'arrête de produire si la taille limite de la mémoire partagé est atteinte.

*Y a t il besoin d'un autre sémaphore ?* : Oui, il nous en faut 2 :
* Un pour limiter le producteur : pas de surécriture dans le fichier partager si le consommateur n'a pas fini de lire celui-ci alors qu'il est rempli.
* Un pour limiter le consommateur : pas de lecture si le producteur n'a produit aucune valeur.

[//]: # (penser à post avant de wait afin d'éviter les interblocage sera une bonne initiative)

