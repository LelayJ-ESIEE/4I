#include <pthread.h>
#include <semaphore.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <string.h>
#include <stdio.h>

#include "../include/gestionFichiers.h"

#define MAX 1000

char buffer[MAX];

void* thread_reader(void* arg){
    int fd;

    if( (fd=open("src.txt", O_RDONLY)) ==-1){
        perror("ouverture src.txt");
        exit(1);
    }

    while(1){
        char* s = litLigne(fd);
        if(s==NULL){
            buffer[0] = EOF;
            break;
        }
        strcpy(buffer, s);
        free(s);
    }
        
    return NULL;
}

void* thread_writer(void* arg){
    int fd;

    if( (fd=open("dst.txt", O_CREAT|O_WRONLY|O_TRUNC)) ==-1){
        perror("ouverture dst.txt");
        exit(1);
    }

    while(1){
        if(buffer[0]==EOF) break;
        ecritLigne(buffer, fd);
    }
        
    return NULL;
}

int main(){
    pthread_t id_reader, id_writer;

    if(pthread_create(&id_reader, NULL, thread_reader, NULL)!=0){
        perror("create thread_reader");
        exit(1);
    }

    if(pthread_create(&id_writer, NULL, thread_writer, NULL)!=0){
        perror("create thread_writer");
        exit(1);
    }

    if(pthread_join(id_reader, NULL)==-1){
        perror("join thread_read");
        exit(1);
    }

    if(pthread_join(id_writer, NULL)==-1){
        perror("join thread_writer");
        exit(1);
    }

    return 0;
}

/*
Problèmes relevés :
    pas d'arrêt
    pas de synchro
        accès possibles au buffer concurrents : dans les deux threads
        écrasement des données sur deux reads consécutifs
*/